{
    "docs": [
        {
            "location": "/", 
            "text": "samsam\n\n\n\n\nSame same, but different\n\n\n\n\nsamsam\n is a collection of predicate and comparison functions useful for\nidentifiying the type of values and to compare values with varying degrees of\nstrictness.\n\n\nsamsam\n is a general-purpose library with no dependencies. It works in browsers\n(including old and rowdy ones, like IE6) and Node. It will define itself as an\nAMD module if you want it to (i.e. if there's a \ndefine\n function available).\n\n\nPredicate functions\n\n\nisArguments(object)\n\n\nReturns \ntrue\n if \nobject\n is an \narguments\n object, \nfalse\n otherwise.\n\n\nisNegZero(value)\n\n\nReturns \ntrue\n if \nvalue\n is \n-0\n.\n\n\nisElement(object)\n\n\nReturns \ntrue\n if \nobject\n is a DOM element node. Unlike\nUnderscore.js/lodash, this function will return \nfalse\n if \nobject\n is an\n\nelement-like\n object, i.e. a regular object with a \nnodeType\n property that\nholds the value \n1\n.\n\n\nisDate(object)\n\n\nReturns true if the object is a \nDate\n, or \ndate-like\n. Duck typing of date\nobjects work by checking that the object has a \ngetTime\n function whose return\nvalue equals the return value from the object's \nvalueOf\n.\n\n\nComparison functions\n\n\nidentical(x, y)\n\n\nStrict equality check according to EcmaScript Harmony's \negal\n.\n\n\nFrom the Harmony wiki:\n\n\n\n\nAn egal function simply makes available the internal \nSameValue\n function\nfrom section 9.12 of the ES5 spec. If two values are egal, then they are not\nobservably distinguishable.\n\n\n\n\nidentical\n returns \ntrue\n when \n===\n is \ntrue\n, except for \n-0\n and\n\n+0\n, where it returns \nfalse\n. Additionally, it returns \ntrue\n when\n\nNaN\n is compared to itself.\n\n\ndeepEqual(obj1, obj2)\n\n\nDeep equal comparison. Two values are \"deep equal\" if:\n\n\n\n\nThey are identical\n\n\nThey are both date objects representing the same time\n\n\nThey are both arrays containing elements that are all deepEqual\n\n\nThey are objects with the same set of properties, and each property\n  in \nobj1\n is deepEqual to the corresponding property in \nobj2\n\n\n\n\nmatch(object, matcher)\n\n\nPartial equality check. Compares \nobject\n with matcher according a wide set of\nrules:\n\n\nString matcher\n\n\nIn its simplest form, \nmatch\n performs a case insensitive substring match.\nWhen the matcher is a string, \nobject\n is converted to a string, and the\nfunction returns \ntrue\n if the matcher is a case-insensitive substring of\n\nobject\n as a string.\n\n\nsamsam.match(\nGive me something\n, \nGive\n); //true\nsamsam.match(\nGive me something\n, \nsumptn\n); // false\nsamsam.match({ toString: function () { return \nyeah\n; } }, \nYeah!\n); // true\n\n\n\n\nThe last example is not symmetric. When the matcher is a string, the \nobject\n\nis coerced to a string - in this case using \ntoString\n. Changing the order of\nthe arguments would cause the matcher to be an object, in which case different\nrules apply (see below).\n\n\nBoolean matcher\n\n\nPerforms a strict (i.e. \n===\n) match with the object. So, only \ntrue\n\nmatches \ntrue\n, and only \nfalse\n matches \nfalse\n.\n\n\nRegular expression matcher\n\n\nWhen the matcher is a regular expression, the function will pass if\n\nobject.test(matcher)\n is \ntrue\n. \nmatch\n is written in a generic way, so\nany object with a \ntest\n method will be used as a matcher this way.\n\n\nsamsam.match(\nGive me something\n, /^[a-z\\s]$/i); // true\nsamsam.match(\nGive me something\n, /[0-9]/); // false\nsamsam.match({ toString: function () { return \nyeah!\n; } }, /yeah/); // true\nsamsam.match(234, /[a-z]/); // false\n\n\n\n\nNumber matcher\n\n\nWhen the matcher is a number, the assertion will pass if \nobject == matcher\n.\n\n\nsamsam.match(\n123\n, 123); // true\nsamsam.match(\nGive me something\n, 425); // false\nsamsam.match({ toString: function () { return \n42\n; } }, 42); // true\nsamsam.match(234, 1234); // false\n\n\n\n\nFunction matcher\n\n\nWhen the matcher is a function, it is called with \nobject\n as its only\nargument. \nmatch\n returns \ntrue\n if the function returns \ntrue\n. A strict\nmatch is performed against the return value, so a boolean \ntrue\n is required,\ntruthy is not enough.\n\n\n// true\nsamsam.match(\n123\n, function (exp) {\n    return exp == \n123\n;\n});\n\n// false\nsamsam.match(\nGive me something\n, function () {\n    return \nok\n;\n});\n\n// true\nsamsam.match({\n    toString: function () {\n        return \n42\n;\n    }\n}, function () { return true; });\n\n// false\nsamsam.match(234, function () {});\n\n\n\n\nObject matcher\n\n\nAs mentioned above, if an object matcher defines a \ntest\n method, \nmatch\n\nwill return \ntrue\n if \nmatcher.test(object)\n returns truthy.\n\n\nIf the matcher does not have a test method, a recursive match is performed. If\nall properties of \nmatcher\n matches corresponding properties in \nobject\n,\n\nmatch\n returns \ntrue\n. Note that the object matcher does not care if the\nnumber of properties in the two objects are the same - only if all properties in\nthe matcher recursively matches ones in \nobject\n.\n\n\n// true\nsamsam.match(\n123\n, {\n    test: function (arg) {\n        return arg == 123;\n    }\n});\n\n// false\nsamsam.match({}, { prop: 42 });\n\n// true\nsamsam.match({\n    name: \nChris\n,\n    profession: \nProgrammer\n\n}, {\n    name: \nChris\n\n});\n\n// false\nsamsam.match(234, { name: \nChris\n });\n\n\n\n\nDOM elements\n\n\nmatch\n can be very helpful when comparing DOM elements, because it allows\nyou to compare several properties with one call:\n\n\nvar el = document.getElementById(\nmyEl\n);\n\nsamsam.match(el, {\n    tagName: \nh2\n,\n    className: \nitem\n,\n    innerHTML: \nHowdy\n\n});", 
            "title": "samsam"
        }, 
        {
            "location": "/#samsam", 
            "text": "Same same, but different   samsam  is a collection of predicate and comparison functions useful for\nidentifiying the type of values and to compare values with varying degrees of\nstrictness.  samsam  is a general-purpose library with no dependencies. It works in browsers\n(including old and rowdy ones, like IE6) and Node. It will define itself as an\nAMD module if you want it to (i.e. if there's a  define  function available).", 
            "title": "samsam"
        }, 
        {
            "location": "/#predicate-functions", 
            "text": "", 
            "title": "Predicate functions"
        }, 
        {
            "location": "/#isargumentsobject", 
            "text": "Returns  true  if  object  is an  arguments  object,  false  otherwise.", 
            "title": "isArguments(object)"
        }, 
        {
            "location": "/#isnegzerovalue", 
            "text": "Returns  true  if  value  is  -0 .", 
            "title": "isNegZero(value)"
        }, 
        {
            "location": "/#iselementobject", 
            "text": "Returns  true  if  object  is a DOM element node. Unlike\nUnderscore.js/lodash, this function will return  false  if  object  is an element-like  object, i.e. a regular object with a  nodeType  property that\nholds the value  1 .", 
            "title": "isElement(object)"
        }, 
        {
            "location": "/#isdateobject", 
            "text": "Returns true if the object is a  Date , or  date-like . Duck typing of date\nobjects work by checking that the object has a  getTime  function whose return\nvalue equals the return value from the object's  valueOf .", 
            "title": "isDate(object)"
        }, 
        {
            "location": "/#comparison-functions", 
            "text": "", 
            "title": "Comparison functions"
        }, 
        {
            "location": "/#identicalx-y", 
            "text": "Strict equality check according to EcmaScript Harmony's  egal .  From the Harmony wiki:   An egal function simply makes available the internal  SameValue  function\nfrom section 9.12 of the ES5 spec. If two values are egal, then they are not\nobservably distinguishable.   identical  returns  true  when  ===  is  true , except for  -0  and +0 , where it returns  false . Additionally, it returns  true  when NaN  is compared to itself.", 
            "title": "identical(x, y)"
        }, 
        {
            "location": "/#deepequalobj1-obj2", 
            "text": "Deep equal comparison. Two values are \"deep equal\" if:   They are identical  They are both date objects representing the same time  They are both arrays containing elements that are all deepEqual  They are objects with the same set of properties, and each property\n  in  obj1  is deepEqual to the corresponding property in  obj2", 
            "title": "deepEqual(obj1, obj2)"
        }, 
        {
            "location": "/#matchobject-matcher", 
            "text": "Partial equality check. Compares  object  with matcher according a wide set of\nrules:", 
            "title": "match(object, matcher)"
        }, 
        {
            "location": "/#string-matcher", 
            "text": "In its simplest form,  match  performs a case insensitive substring match.\nWhen the matcher is a string,  object  is converted to a string, and the\nfunction returns  true  if the matcher is a case-insensitive substring of object  as a string.  samsam.match( Give me something ,  Give ); //true\nsamsam.match( Give me something ,  sumptn ); // false\nsamsam.match({ toString: function () { return  yeah ; } },  Yeah! ); // true  The last example is not symmetric. When the matcher is a string, the  object \nis coerced to a string - in this case using  toString . Changing the order of\nthe arguments would cause the matcher to be an object, in which case different\nrules apply (see below).", 
            "title": "String matcher"
        }, 
        {
            "location": "/#boolean-matcher", 
            "text": "Performs a strict (i.e.  === ) match with the object. So, only  true \nmatches  true , and only  false  matches  false .", 
            "title": "Boolean matcher"
        }, 
        {
            "location": "/#regular-expression-matcher", 
            "text": "When the matcher is a regular expression, the function will pass if object.test(matcher)  is  true .  match  is written in a generic way, so\nany object with a  test  method will be used as a matcher this way.  samsam.match( Give me something , /^[a-z\\s]$/i); // true\nsamsam.match( Give me something , /[0-9]/); // false\nsamsam.match({ toString: function () { return  yeah! ; } }, /yeah/); // true\nsamsam.match(234, /[a-z]/); // false", 
            "title": "Regular expression matcher"
        }, 
        {
            "location": "/#number-matcher", 
            "text": "When the matcher is a number, the assertion will pass if  object == matcher .  samsam.match( 123 , 123); // true\nsamsam.match( Give me something , 425); // false\nsamsam.match({ toString: function () { return  42 ; } }, 42); // true\nsamsam.match(234, 1234); // false", 
            "title": "Number matcher"
        }, 
        {
            "location": "/#function-matcher", 
            "text": "When the matcher is a function, it is called with  object  as its only\nargument.  match  returns  true  if the function returns  true . A strict\nmatch is performed against the return value, so a boolean  true  is required,\ntruthy is not enough.  // true\nsamsam.match( 123 , function (exp) {\n    return exp ==  123 ;\n});\n\n// false\nsamsam.match( Give me something , function () {\n    return  ok ;\n});\n\n// true\nsamsam.match({\n    toString: function () {\n        return  42 ;\n    }\n}, function () { return true; });\n\n// false\nsamsam.match(234, function () {});", 
            "title": "Function matcher"
        }, 
        {
            "location": "/#object-matcher", 
            "text": "As mentioned above, if an object matcher defines a  test  method,  match \nwill return  true  if  matcher.test(object)  returns truthy.  If the matcher does not have a test method, a recursive match is performed. If\nall properties of  matcher  matches corresponding properties in  object , match  returns  true . Note that the object matcher does not care if the\nnumber of properties in the two objects are the same - only if all properties in\nthe matcher recursively matches ones in  object .  // true\nsamsam.match( 123 , {\n    test: function (arg) {\n        return arg == 123;\n    }\n});\n\n// false\nsamsam.match({}, { prop: 42 });\n\n// true\nsamsam.match({\n    name:  Chris ,\n    profession:  Programmer \n}, {\n    name:  Chris \n});\n\n// false\nsamsam.match(234, { name:  Chris  });", 
            "title": "Object matcher"
        }, 
        {
            "location": "/#dom-elements", 
            "text": "match  can be very helpful when comparing DOM elements, because it allows\nyou to compare several properties with one call:  var el = document.getElementById( myEl );\n\nsamsam.match(el, {\n    tagName:  h2 ,\n    className:  item ,\n    innerHTML:  Howdy \n});", 
            "title": "DOM elements"
        }
    ]
}